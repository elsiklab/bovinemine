package org.modmine.web;

/*
 * Copyright (C) 2002-2014 FlyMine
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  See the LICENSE file for more
 * information or http://www.gnu.org/copyleft/lesser.html.
 *
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.intermine.api.InterMineAPI;
import org.intermine.model.bio.Gene;
import org.intermine.model.bio.Location;
import org.intermine.model.bio.SequenceFeature;
import org.intermine.model.bio.Submission;
import org.intermine.objectstore.ObjectStore;
import org.intermine.objectstore.ObjectStoreException;
import org.intermine.objectstore.intermine.ObjectStoreInterMineImpl;
import org.intermine.objectstore.query.ConstraintOp;
import org.intermine.objectstore.query.ConstraintSet;
import org.intermine.objectstore.query.ContainsConstraint;
import org.intermine.objectstore.query.OverlapConstraint;
import org.intermine.objectstore.query.OverlapRange;
import org.intermine.objectstore.query.Query;
import org.intermine.objectstore.query.QueryClass;
import org.intermine.objectstore.query.QueryCollectionReference;
import org.intermine.objectstore.query.QueryExpression;
import org.intermine.objectstore.query.QueryField;
import org.intermine.objectstore.query.QueryForeignKey;
import org.intermine.objectstore.query.QueryObjectReference;
import org.intermine.objectstore.query.QueryValue;
import org.intermine.objectstore.query.Results;
import org.intermine.objectstore.query.ResultsRow;
import org.intermine.objectstore.query.SimpleConstraint;
import org.intermine.pathquery.Constraints;
import org.intermine.pathquery.PathQuery;
import org.intermine.util.DynamicUtil;
import org.intermine.web.logic.session.SessionMethods;
import org.intermine.web.struts.ForwardParameters;
import org.intermine.web.struts.InterMineAction;

/**
 * Generate queries for overlaps of submission features and overlaps with gene
 * flanking regions.
 *
 * @author Richard Smith
 *
 */
public class SubmissionOverlapsAction extends InterMineAction
{
    private static final Logger LOG = Logger.getLogger(SubmissionOverlapsAction.class);

    /**
     * Action for creating a bag of InterMineObjects or Strings from identifiers
     * in text field.
     *
     * @param mapping        The ActionMapping used to select this instance
     * @param form           The optional ActionForm bean for this request (if any)
     * @param request        The HTTP request we are processing
     * @param response       The HTTP response we are creating
     * @return an ActionForward object defining where control goes next
     * @exception Exception  if the application business logic throws an exception
     */
    public ActionForward execute(ActionMapping mapping, ActionForm form,
            HttpServletRequest request, HttpServletResponse response)
        throws Exception {
        final InterMineAPI im = SessionMethods.getInterMineAPI(request
                .getSession());
        ObjectStore os = im.getObjectStore();

        long bT = System.currentTimeMillis();     // to monitor time spent in the process
        SubmissionOverlapsForm submissionOverlapsForm = (SubmissionOverlapsForm) form;
        String submissionId = submissionOverlapsForm.getSubmissionId();

        PathQuery q = new PathQuery(os.getModel());

//        if (request.getParameter("overlaps") != null) {
        buildOverlapPathQuery(submissionOverlapsForm, q, im);
//        }

        String qid = SessionMethods.startQueryWithTimeout(request, false, q);
        Thread.sleep(200);

        String trail = "|" + submissionId;

        LOG.info("OVERLAP:TOTALTIME: execute: " + (System.currentTimeMillis() - bT) + " ms");

        return new ForwardParameters(mapping.findForward("waiting")).addParameter("qid", qid)
                .addParameter("trail", trail).forward();
    }

    /**
     * @param submissionOverlapsForm
     * @param submissionTitle
     * @param q
     */
    private void buildOverlapPathQuery(
            SubmissionOverlapsForm submissionOverlapsForm, PathQuery q, InterMineAPI im)
        throws ObjectStoreException, ClassNotFoundException {

        String submissionTitle = submissionOverlapsForm.getSubmissionTitle();
        String givenFeatureType = submissionOverlapsForm.getOverlapFeatureType();
        String overlapFeatureType = submissionOverlapsForm.getOverlapFindType();
        String description = "Results of searching for " + overlapFeatureType
                + "s that overlap " + givenFeatureType + "s generated by submission "
                + submissionTitle + ".";
        q.setDescription(description);

//        q.addViews("overlapFeatureType.primaryIdentifier");

        q.addView(overlapFeatureType + ".primaryIdentifier");

        if ("Gene".equals(overlapFeatureType)) {
            q.addView(overlapFeatureType + ".symbol");
        }

        q.addView(overlapFeatureType + ".chromosomeLocation.start");
        q.addView(overlapFeatureType + ".chromosomeLocation.end");
        q.addView(overlapFeatureType + ".chromosomeLocation.strand");

        if ("Exon".equals(overlapFeatureType)) {
            q.addView(overlapFeatureType + ".gene.primaryIdentifier");
        }


        // this was needed after the new result tables:
        // the inIds was not serializable, and therefore could not be used by the webservice
        // substituted by the ONE OF constraint, which performed about 10% worse
        // can go now!
//      Set<String> idS = new HashSet<String>();
//      for(Integer integer : getOverlappingFeaturesId(submissionOverlapsForm, im))
//          idS.add(integer.toString());
//      q.addConstraint(Constraints.oneOfValues(overlapFeatureType + ".id", idS));

        q.addConstraint(Constraints.inIds(overlapFeatureType,
                getOverlappingFeaturesId(submissionOverlapsForm, im)));


//        LOG.info("OVERLAP QUERY: " + q.toString());
//        LOG.info("OVERLAP QUERYJSON: " + q.toJson());

    }


    private Set<Integer> getOverlappingFeaturesId(
            SubmissionOverlapsForm submissionOverlapsForm, InterMineAPI im)
        throws ObjectStoreException, ClassNotFoundException {
        long bT = System.currentTimeMillis();     // to monitor time spent in the process

        String direction = submissionOverlapsForm.getDirection();
        int distance = Integer.valueOf(submissionOverlapsForm.getDistance());
        String featureType = submissionOverlapsForm.getOverlapFeatureType();  //GF
        String findFeatureType = submissionOverlapsForm.getOverlapFindType(); //OF--gene
        String submissionId = submissionOverlapsForm.getSubmissionId();

        LOG.info("OVERLAP FORM distance: " + distance);
        LOG.info("OVERLAP FORM direction: " + direction);
        LOG.info("OVERLAP FORM overlap feat: " + findFeatureType);
        LOG.info("OVERLAP FORM given feat: " + featureType);

//        Submission submission = (Submission) im.getObjectStore().getObjectById(
//                Integer.valueOf(submissionId));

        // this to allow url of the type
        // /submissionOverlapsAction.do?submissionDCCId=modENCODE_3320
        // &overlapFindType=Gene&distance=500&direction=downstream&overlapFeatureType=BindingSite

        String submissionDCCId = submissionOverlapsForm.getSubmissionDCCId();
        Submission submission = null;
        if (submissionId != null) { // the case via webapp form
            submission = (Submission) im.getObjectStore().getObjectById(
                    Integer.valueOf(submissionId));
        } else { // url
            submission =
                    (Submission) DynamicUtil.createObject(Collections.singleton(Submission.class));
            submission.setdCCid(submissionDCCId);

            submission = (Submission) im.getObjectStore().getObjectByExample(submission,
                    new HashSet<String>(Arrays.asList("DCCid")));
        }

        int organismId = submission.getOrganism().getId();

        int beforeStartOfOF = getLeftMargin(direction, distance);
        int afterEndOfOF = getRightMargin(direction, distance);

        String modelPackName = im.getModel().getPackageName();
        Class<?> featureCls = Class.forName(modelPackName + "." + featureType);
        Class<?> overlapFeatureCls = Class.forName(modelPackName + "." + findFeatureType);

        Query query = new Query();
        query.setDistinct(false);

        QueryClass qcGivenFeature = new QueryClass(featureCls);
        QueryClass qcOverlapFeature = new QueryClass(overlapFeatureCls);
        QueryClass qcGivenFeatureLoc = new QueryClass(Location.class);
        QueryClass qcOverlapFeatureLoc = new QueryClass(Location.class);
//        QueryClass qcSequenceFeature = new QueryClass(SequenceFeature.class);
//               QueryField qfSequenceFeatureId = new QueryField(qcSequenceFeature, "id");
        QueryField qfOFId = new QueryField(qcOverlapFeature, "id");
        query.addToSelect(qfOFId);
//                query.addToSelect(qfSequenceFeatureId);

        query.addFrom(qcGivenFeature);
        query.addFrom(qcOverlapFeature);
        query.addFrom(qcGivenFeatureLoc);
        query.addFrom(qcOverlapFeatureLoc);

        ConstraintSet constraints = new ConstraintSet(ConstraintOp.AND);
        query.setConstraint(constraints);

        QueryObjectReference locOFSubject = new QueryObjectReference(
                qcOverlapFeatureLoc, "feature");
        ContainsConstraint ccLocOFSubject = new ContainsConstraint(
                locOFSubject, ConstraintOp.CONTAINS, qcOverlapFeature);
        constraints.addConstraint(ccLocOFSubject);

        QueryObjectReference locGFSubject = new QueryObjectReference(
                qcGivenFeatureLoc, "feature");
        ContainsConstraint ccLocGFSubject = new ContainsConstraint(
                locGFSubject, ConstraintOp.CONTAINS,
                qcGivenFeature);
        constraints.addConstraint(ccLocGFSubject);

        // SequenceFeaure.chromosome = Gene.chromosome
        constraints.addConstraint(new SimpleConstraint(new QueryForeignKey(
                qcOverlapFeature, "chromosome"), ConstraintOp.EQUALS,
                new QueryForeignKey(qcGivenFeature, "chromosome")));

        // SequenceFeaure.organism = Gene.organism
        constraints.addConstraint(new SimpleConstraint(new QueryForeignKey(
                qcOverlapFeature, "organism"), ConstraintOp.EQUALS, new QueryForeignKey(
                        qcGivenFeature, "organism")));

        SimpleConstraint scOrg = new SimpleConstraint(new QueryForeignKey(
                qcOverlapFeature, "organism"), ConstraintOp.EQUALS, new QueryValue(
                        organismId));
        constraints.addConstraint(scOrg);

        QueryCollectionReference qcrSubmission = new QueryCollectionReference(
                submission, "features");
        constraints.addConstraint(new ContainsConstraint(qcrSubmission,
                ConstraintOp.CONTAINS, qcGivenFeature));

        // Sequence feature location chromosome reference
        QueryObjectReference givenFeatureLocatedOnRef = new QueryObjectReference(
                qcGivenFeatureLoc, "locatedOn");

        // Gene location chromosome reference
        QueryObjectReference overlapFeatureLocatedOnRef = new QueryObjectReference(
                qcOverlapFeatureLoc, "locatedOn");

        OverlapRange givenFeatureRange = new OverlapRange(new QueryField(
                qcGivenFeatureLoc, "start"), new QueryField(
                        qcGivenFeatureLoc, "end"), givenFeatureLocatedOnRef);

//        OverlapRange overlapFeatureRangeold = new OverlapRange(new QueryExpression(
//                new QueryField(qcOverlapFeatureLoc, "start"), QueryExpression.SUBTRACT,
//                new QueryValue(beforeStartOfOF)), new QueryExpression(
//                        new QueryField(qcOverlapFeatureLoc, "end"), QueryExpression.ADD,
//                        new QueryValue(afterEndOfOF)), overlapFeatureLocatedOnRef);

        OverlapRange overlapFeatureRange = new OverlapRange(new QueryExpression(new QueryValue(1),
                QueryExpression.GREATEST,
                new QueryExpression(new QueryField(qcOverlapFeatureLoc, "start"),
                        QueryExpression.SUBTRACT, new QueryValue(beforeStartOfOF))),
                        new QueryExpression(
                        new QueryField(qcOverlapFeatureLoc, "end"), QueryExpression.ADD,
                        new QueryValue(afterEndOfOF)), overlapFeatureLocatedOnRef);


        OverlapConstraint oc = new OverlapConstraint(givenFeatureRange,
                ConstraintOp.OVERLAPS, overlapFeatureRange);

        constraints.addConstraint(oc);

        ObjectStoreInterMineImpl ob = (ObjectStoreInterMineImpl) im.getObjectStore();

        LOG.debug("OVERLAP --" + ob.generateSql(query));

        Results results = im.getObjectStore().execute(query, 100000, true, false, true);
//        SingletonResults results = im.getObjectStore()
//                .executeSingleton(query, 100000,true, false, true);

        Set<Integer> overlapFeatureIdSet = new HashSet<Integer>();

        if (results == null || results.isEmpty()) {
            LOG.warn("OVERLAP no ovelappingIdSet!! " + overlapFeatureIdSet);
            return overlapFeatureIdSet;
        }

        for (Iterator<?> iter = results.iterator(); iter.hasNext();) {
            ResultsRow<?> row = (ResultsRow<?>) iter.next();
            overlapFeatureIdSet.add((Integer) row.get(0));
        }

        LOG.info("OVERLAP TIME: " + (System.currentTimeMillis() - bT) + " ms");
        return overlapFeatureIdSet;
    }

    /**
     * @param distance
     * @param direction
     * @return
     */
    private int getLeftMargin(String direction, int distance) {
        if ("downstream".equalsIgnoreCase(direction)) {
            return 0;
        } else {
            return distance;
        }
    }

    /**
     * @param distance
     * @param direction
     * @return
     */
    private int getRightMargin(String direction, int distance) {
        if ("upstream".equalsIgnoreCase(direction)) {
            return 0;
        } else {
            return distance;
        }
    }

}
